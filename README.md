# DSA Patterns in Java

This repository contains solutions to common problems in **Data Structures and Algorithms (DSA)**, organized by algorithmic patterns. It aims to help learners and developers practice and master DSA concepts by implementing them in Java. Each problem is categorized based on well-known DSA patterns such as **Sliding Window**, **Two Pointers**, **Backtracking**, **Dynamic Programming**, and more.

Whether you're a beginner looking to get started with DSA or an experienced developer looking for algorithmic patterns and problem-solving techniques, this repo has something for everyone!

## Key Features

- **Pattern-based organization:** Problems are categorized into different algorithmic patterns for easy learning and understanding.
- **Clean, commented code:** Each solution is written in Java, with detailed explanations to enhance learning.
- **Time and Space Complexity Analysis:** For each solution, I have included the time and space complexity to help you understand the efficiency of the algorithms.
- **Regular Updates:** New patterns and problems will be added over time to ensure the repository stays relevant and up-to-date.

## Table of Contents

- [Patterns](#patterns)
  - [Sliding Window](#sliding-window)
  - [Two Pointers](#two-pointers)
  - [Backtracking](#backtracking)
  - [Dynamic Programming](#dynamic-programming)
  - [Greedy Algorithms](#greedy-algorithms)
  - [Binary Search](#binary-search)
  - [Stack & Queue Patterns](#stack-queue-patterns)
  - [Graph Algorithms](#graph-algorithms)
  - [Tree Algorithms](#tree-algorithms)
- [How to Use](#how-to-use)
- [Contributing](#contributing)
- [License](#license)

## Patterns

### Sliding Window

- **Max Sum Subarray of Size K**  
- **Longest Substring Without Repeating Characters**  
- **Find All Anagrams in a String**  

### Two Pointers

- **Pair With Target Sum**  
- **Remove Duplicates from Sorted Array**  
- **Container With Most Water**  

### Backtracking

- **Permutations**  
- **Subsets**  
- **Combination Sum**  

### Dynamic Programming

- **Fibonacci Sequence**  
- **Longest Common Subsequence**  
- **0/1 Knapsack Problem**  

### Greedy Algorithms

- **Activity Selection Problem**  
- **Job Scheduling with Deadlines**  
- **Fractional Knapsack**  

### Binary Search

- **Binary Search on Sorted Array**  
- **Search in Rotated Sorted Array**  
- **Find Peak Element**  

### Stack & Queue Patterns

- **Valid Parentheses**  
- **Next Greater Element**  
- **Sliding Window Maximum**  

### Graph Algorithms

- **Depth-First Search (DFS)**  
- **Breadth-First Search (BFS)**  
- **Topological Sort**  
- **Dijkstra’s Algorithm**

### Tree Algorithms

- **Binary Tree Inorder Traversal**  
- **Binary Tree Level Order Traversal**  
- **Balanced Binary Tree Check**  
- **Lowest Common Ancestor (LCA)**  

## How to Use

1. Clone the repository to your local machine:

    ```bash
    git clone https://github.com/yourusername/DSA-Patterns-in-Java.git
    ```

2. Navigate to the desired pattern folder (e.g., `SlidingWindow`, `TwoPointers`, etc.) to find the problem you want to work on.

3. Open the Java files and execute them using your preferred IDE or run them in the terminal:

    ```bash
    javac MaxSumSubarray.java
    java MaxSumSubarray
    ```

4. Explore other patterns and problems by navigating through the respective directories.

## Contributing

Contributions are welcome! If you would like to contribute, follow these steps:

1. Fork the repository by clicking the "Fork" button in the top-right corner.
2. Clone your fork:

    ```bash
    git clone https://github.com/yourusername/DSA-Patterns-in-Java.git
    ```

3. Create a new branch for your changes:

    ```bash
    git checkout -b feature-branch
    ```

4. Add your solution(s) to the appropriate folder.
5. Push your changes:

    ```bash
    git push origin feature-branch
    ```

6. Create a pull request (PR) explaining the changes you’ve made.

### Code Style
Please follow Java conventions for clean and readable code. Make sure to:
- Use meaningful variable names.
- Include comments for better understanding.
- Include a time and space complexity analysis for each solution.
